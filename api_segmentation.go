/*
 * Copyright 2022 ByteDance and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * CDP开放接口
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 2023-02-10
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// Linger please
var (
	_ context.Context
	_ os.File
)

type SegmentationApiService service

/*
SegmentationApiService 分群ID文件下载
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenantId
 * @param segId
 * @param formatType 文件格式，GZ, TXT, CSV 可选
 * @param optional nil or *SegmentationApiDownloadSegFileOpts - Optional Parameters:
     * @param "NeedEncrypt" (optional.Bool) -
@return *os.File
*/

type SegmentationApiDownloadSegFileOpts struct {
	NeedEncrypt optional.Bool
}

func (a *SegmentationApiService) DownloadSegFile(ctx context.Context, tenantId int32, segId int32, formatType string, localVarOptionals *SegmentationApiDownloadSegFileOpts) (*os.File, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.Host + a.client.cfg.BasePath
	localVarQueryParams := url.Values{}
	localVarQueryParams.Add("tenantId", fmt.Sprintf("%v", tenantId))
	localVarQueryParams.Add("segId", fmt.Sprintf("%v", segId))

	localVarHeaderParams := make(map[string]string)

	localVarFormParams := url.Values{}
	localVarQueryParams.Add("Action", "QueryOpenPlatformOpenApi")
	localVarQueryParams.Add("Version", "2022-12-16")
	localVarQueryParams.Add("ApiAction", "DownloadSegFile")
	localVarQueryParams.Add("ApiVersion", "2023-02-10")

	localVarQueryParams.Add("formatType", parameterToString(formatType, ""))
	if localVarOptionals != nil && localVarOptionals.NeedEncrypt.IsSet() {
		localVarQueryParams.Add("needEncrypt", parameterToString(localVarOptionals.NeedEncrypt.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if len(localVarHttpHeaderAccepts) > 0 {
		respType := localVarHttpResponse.Header.Values("Content-Type")
		for _, respType := range respType {
			for _, accept := range localVarHttpHeaderAccepts {
				if respType == accept {
					goto RESP_TYPE_CHECK_END
				}
			}
		}
		return localVarReturnValue, localVarHttpResponse, fmt.Errorf("Content-Type %v not accept, body: \"%v\"", respType, string(localVarBody))
	}
RESP_TYPE_CHECK_END:

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header)
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header)
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SegmentationApiService 创建上传分群
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param tenantId
@return ByteDanceResponseRecordSegShardInfoResp
*/
func (a *SegmentationApiService) LegacyCreateUploadSegment(ctx context.Context, body LegacyUploadedSegCreateRequest, tenantId int32) (ByteDanceResponseRecordSegShardInfoResp, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ByteDanceResponseRecordSegShardInfoResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.Host + a.client.cfg.BasePath
	localVarQueryParams := url.Values{}
	localVarQueryParams.Add("tenantId", fmt.Sprintf("%v", tenantId))

	localVarHeaderParams := make(map[string]string)

	localVarFormParams := url.Values{}
	localVarQueryParams.Add("Action", "QueryOpenPlatformOpenApi")
	localVarQueryParams.Add("Version", "2022-12-16")
	localVarQueryParams.Add("ApiAction", "LegacyCreateUploadSegment")
	localVarQueryParams.Add("ApiVersion", "2023-02-10")

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if len(localVarHttpHeaderAccepts) > 0 {
		respType := localVarHttpResponse.Header.Values("Content-Type")
		for _, respType := range respType {
			for _, accept := range localVarHttpHeaderAccepts {
				if respType == accept {
					goto RESP_TYPE_CHECK_END
				}
			}
		}
		return localVarReturnValue, localVarHttpResponse, fmt.Errorf("Content-Type %v not accept, body: \"%v\"", respType, string(localVarBody))
	}
RESP_TYPE_CHECK_END:

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header)
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ByteDanceResponseRecordSegShardInfoResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header)
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SegmentationApiService 分群详情
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenantId
 * @param segId
@return ByteDanceResponseSegmentationResp
*/
func (a *SegmentationApiService) LegacyGetSegment(ctx context.Context, tenantId int32, segId int32) (ByteDanceResponseSegmentationResp, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ByteDanceResponseSegmentationResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.Host + a.client.cfg.BasePath
	localVarQueryParams := url.Values{}
	localVarQueryParams.Add("tenantId", fmt.Sprintf("%v", tenantId))
	localVarQueryParams.Add("segId", fmt.Sprintf("%v", segId))

	localVarHeaderParams := make(map[string]string)

	localVarFormParams := url.Values{}
	localVarQueryParams.Add("Action", "QueryOpenPlatformOpenApi")
	localVarQueryParams.Add("Version", "2022-12-16")
	localVarQueryParams.Add("ApiAction", "LegacyGetSegment")
	localVarQueryParams.Add("ApiVersion", "2023-02-10")

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if len(localVarHttpHeaderAccepts) > 0 {
		respType := localVarHttpResponse.Header.Values("Content-Type")
		for _, respType := range respType {
			for _, accept := range localVarHttpHeaderAccepts {
				if respType == accept {
					goto RESP_TYPE_CHECK_END
				}
			}
		}
		return localVarReturnValue, localVarHttpResponse, fmt.Errorf("Content-Type %v not accept, body: \"%v\"", respType, string(localVarBody))
	}
RESP_TYPE_CHECK_END:

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header)
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ByteDanceResponseSegmentationResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header)
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SegmentationApiService 分群列表查看，分页
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenantId
 * @param optional nil or *SegmentationApiLegacyGetSegmentListOpts - Optional Parameters:
     * @param "Current" (optional.Int32) -  页码
     * @param "PageSize" (optional.Int32) -  每页大小
     * @param "Keyword" (optional.String) -  关键词，模糊搜索分群名称和创建人
     * @param "IsSelfSee" (optional.Bool) -  是否只看自己创建的
     * @param "IsOnlySourceReady" (optional.Bool) -  是否分群就绪的（文件+洞察）
     * @param "IdType" (optional.String) -  实体类型code
     * @param "SegTypes" (optional.String) -  分群类型，逗号分隔，多选
     * @param "SourcePlatform" (optional.String) -  来源平台
     * @param "IsAbaseAvailable" (optional.Bool) -  筛选在线服务是否可用
     * @param "IsAbaseEnabled" (optional.Bool) -  筛选在线服务配置开启
@return ByteDanceResponseSegmentationListResp
*/

type SegmentationApiLegacyGetSegmentListOpts struct {
	Current           optional.Int32
	PageSize          optional.Int32
	Keyword           optional.String
	IsSelfSee         optional.Bool
	IsOnlySourceReady optional.Bool
	IdType            optional.String
	SegTypes          optional.String
	SourcePlatform    optional.String
	IsAbaseAvailable  optional.Bool
	IsAbaseEnabled    optional.Bool
}

func (a *SegmentationApiService) LegacyGetSegmentList(ctx context.Context, tenantId int32, localVarOptionals *SegmentationApiLegacyGetSegmentListOpts) (ByteDanceResponseSegmentationListResp, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ByteDanceResponseSegmentationListResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.Host + a.client.cfg.BasePath
	localVarQueryParams := url.Values{}
	localVarQueryParams.Add("tenantId", fmt.Sprintf("%v", tenantId))

	localVarHeaderParams := make(map[string]string)

	localVarFormParams := url.Values{}
	localVarQueryParams.Add("Action", "QueryOpenPlatformOpenApi")
	localVarQueryParams.Add("Version", "2022-12-16")
	localVarQueryParams.Add("ApiAction", "LegacyGetSegmentList")
	localVarQueryParams.Add("ApiVersion", "2023-02-10")

	if localVarOptionals != nil && localVarOptionals.Current.IsSet() {
		localVarQueryParams.Add("current", parameterToString(localVarOptionals.Current.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Keyword.IsSet() {
		localVarQueryParams.Add("keyword", parameterToString(localVarOptionals.Keyword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsSelfSee.IsSet() {
		localVarQueryParams.Add("isSelfSee", parameterToString(localVarOptionals.IsSelfSee.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsOnlySourceReady.IsSet() {
		localVarQueryParams.Add("isOnlySourceReady", parameterToString(localVarOptionals.IsOnlySourceReady.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdType.IsSet() {
		localVarQueryParams.Add("idType", parameterToString(localVarOptionals.IdType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SegTypes.IsSet() {
		localVarQueryParams.Add("segTypes", parameterToString(localVarOptionals.SegTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourcePlatform.IsSet() {
		localVarQueryParams.Add("sourcePlatform", parameterToString(localVarOptionals.SourcePlatform.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsAbaseAvailable.IsSet() {
		localVarQueryParams.Add("isAbaseAvailable", parameterToString(localVarOptionals.IsAbaseAvailable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsAbaseEnabled.IsSet() {
		localVarQueryParams.Add("isAbaseEnabled", parameterToString(localVarOptionals.IsAbaseEnabled.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if len(localVarHttpHeaderAccepts) > 0 {
		respType := localVarHttpResponse.Header.Values("Content-Type")
		for _, respType := range respType {
			for _, accept := range localVarHttpHeaderAccepts {
				if respType == accept {
					goto RESP_TYPE_CHECK_END
				}
			}
		}
		return localVarReturnValue, localVarHttpResponse, fmt.Errorf("Content-Type %v not accept, body: \"%v\"", respType, string(localVarBody))
	}
RESP_TYPE_CHECK_END:

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header)
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ByteDanceResponseSegmentationListResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header)
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SegmentationApiService 分群在线服务开启/关闭
开启/关闭单个分群的在线服务
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param tenantId
 * @param segId
@return ByteDanceResponseSegmentationOnlineServiceEnableResp
*/
func (a *SegmentationApiService) SegmentOnlineServiceEnable(ctx context.Context, body ByteDanceResponseSegmentationOnlineServiceEnableReq, tenantId int32, segId int32) (ByteDanceResponseSegmentationOnlineServiceEnableResp, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Patch")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ByteDanceResponseSegmentationOnlineServiceEnableResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.Host + a.client.cfg.BasePath
	localVarQueryParams := url.Values{}
	localVarQueryParams.Add("tenantId", fmt.Sprintf("%v", tenantId))
	localVarQueryParams.Add("segId", fmt.Sprintf("%v", segId))

	localVarHeaderParams := make(map[string]string)

	localVarFormParams := url.Values{}
	localVarQueryParams.Add("Action", "QueryOpenPlatformOpenApi")
	localVarQueryParams.Add("Version", "2022-12-16")
	localVarQueryParams.Add("ApiAction", "SegmentOnlineServiceEnable")
	localVarQueryParams.Add("ApiVersion", "2023-02-10")

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if len(localVarHttpHeaderAccepts) > 0 {
		respType := localVarHttpResponse.Header.Values("Content-Type")
		for _, respType := range respType {
			for _, accept := range localVarHttpHeaderAccepts {
				if respType == accept {
					goto RESP_TYPE_CHECK_END
				}
			}
		}
		return localVarReturnValue, localVarHttpResponse, fmt.Errorf("Content-Type %v not accept, body: \"%v\"", respType, string(localVarBody))
	}
RESP_TYPE_CHECK_END:

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header)
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ByteDanceResponseSegmentationOnlineServiceEnableResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header)
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SegmentationApiService 上传分群文件
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param file
 * @param tenantId
@return ByteDanceResponseSegmentationUploadResp
*/
func (a *SegmentationApiService) UploadSegFile(ctx context.Context, file *os.File, tenantId int32) (ByteDanceResponseSegmentationUploadResp, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ByteDanceResponseSegmentationUploadResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.Host + a.client.cfg.BasePath
	localVarQueryParams := url.Values{}
	localVarQueryParams.Add("tenantId", fmt.Sprintf("%v", tenantId))

	localVarHeaderParams := make(map[string]string)

	localVarFormParams := url.Values{}
	localVarQueryParams.Add("Action", "QueryOpenPlatformOpenApi")
	localVarQueryParams.Add("Version", "2022-12-16")
	localVarQueryParams.Add("ApiAction", "UploadSegFile")
	localVarQueryParams.Add("ApiVersion", "2023-02-10")

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFile := file
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if len(localVarHttpHeaderAccepts) > 0 {
		respType := localVarHttpResponse.Header.Values("Content-Type")
		for _, respType := range respType {
			for _, accept := range localVarHttpHeaderAccepts {
				if respType == accept {
					goto RESP_TYPE_CHECK_END
				}
			}
		}
		return localVarReturnValue, localVarHttpResponse, fmt.Errorf("Content-Type %v not accept, body: \"%v\"", respType, string(localVarBody))
	}
RESP_TYPE_CHECK_END:

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header)
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ByteDanceResponseSegmentationUploadResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header)
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
